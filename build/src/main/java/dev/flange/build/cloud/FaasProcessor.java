/*
 * Copyright © 2023 GlobalMentor, Inc. <https://www.globalmentor.com/>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dev.flange.build.cloud;

import static javax.tools.Diagnostic.Kind.*;

import java.io.IOException;
import java.util.Set;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import javax.lang.model.util.ElementFilter;

import com.squareup.javapoet.*;

/**
 * Annotation processor for FaaS.
 * @author Garret Wilson
 */
@SupportedAnnotationTypes("dev.flange.cloud.FaasService")
public class FaasProcessor extends AbstractProcessor {

	/**
	 * {@inheritDoc}
	 * @implSpec This processor supports the latest supported source version.
	 */
	@Override
	public SourceVersion getSupportedSourceVersion() {
		return SourceVersion.latestSupported();
	}

	private static final ClassName FAAS_SERVICE_LAMBDA_HANDLER_CLASS_NAME = ClassName.get("dev.flange.cloud.aws", "FaasServiceLambdaHandler");

	private static final String LAMBDA_HANDLER_CLASS_NAME_SUFFIX = "_FlangeLambdaHandler";

	@Override
	public boolean process(final Set<? extends TypeElement> annotations, final RoundEnvironment roundEnvironment) {
		for(TypeElement annotation : annotations) {
			final Set<? extends Element> annotatedElements = roundEnvironment.getElementsAnnotatedWith(annotation);
			final Set<TypeElement> typeElements = ElementFilter.typesIn(annotatedElements);
			//TODO raise error if there are non-type elements
			for(final TypeElement typeElement : typeElements) {
				final ClassName lambdaImplClassName = ClassName.get(typeElement);
				final ClassName lambdaHandlerClassName = ClassName.get(lambdaImplClassName.packageName(),
						lambdaImplClassName.simpleName() + LAMBDA_HANDLER_CLASS_NAME_SUFFIX);
				final TypeName lambdaHandlerSuperClassName = ParameterizedTypeName.get(FAAS_SERVICE_LAMBDA_HANDLER_CLASS_NAME, lambdaImplClassName);
				//public final class MyServiceImpl_FlangeLambdaHandler …
				final TypeSpec lambdaHandlerClassSpec = TypeSpec.classBuilder(lambdaHandlerClassName).addModifiers(Modifier.PUBLIC, Modifier.FINAL)
						.superclass(lambdaHandlerSuperClassName) //
						.addJavadoc("AWS Lambda handler stub for {@link $T}.", lambdaImplClassName) //
						.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC) //constructor
								.addJavadoc("Constructor.") //
								.addStatement("super($T.class)", lambdaImplClassName).build())
						.build();
				final JavaFile lambdaHandlerClassJavaFile = JavaFile.builder(lambdaImplClassName.packageName(), lambdaHandlerClassSpec) //
						.addFileComment("""
								File generated by [Flange](https://flange.dev/), a tool by
								[GlobalMentor, Inc.](https://www.globalmentor.com/).

								_Normally this file should not be edited manually._""").build();
				try {
					lambdaHandlerClassJavaFile.writeTo(processingEnv.getFiler());
				} catch(final IOException ioException) {
					processingEnv.getMessager().printMessage(ERROR, ioException.getMessage()); //TODO improve
				}
			}
		}
		return true;
	}

}
